class Solution {
public:
    int minSwaps(vector<int>& nums) {
        int k = accumulate(nums.begin(), nums.end(), 0);
        int n = nums.size();
        int ans = 0, count_1 = 0;
        
        for (int i = 0; i < k; i++) {
            count_1 += nums[i];
        }
        
        ans = count_1;
        
        for (int i = k; i < n + k; i++) {
            count_1 += nums[i % n];
            count_1 -= nums[(i - k + n) % n];
            ans = max(ans, count_1);
        }

        return k - ans;
    }
};







#include <vector>
#include <unordered_map>
using namespace std;

#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    int minFlips(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();

        int totalRowFlips = 0;
        int totalColFlips = 0;

        // Calculate row flips
        for (int i = 0; i < m; ++i) {
            int rowFlips = 0;
            for (int j = 0, k = n - 1; j < k; ++j, --k) {
                if (grid[i][j] != grid[i][k]) {
                    rowFlips++;
                }
            }
            totalRowFlips += ress;
        }

        // Calculate column flips
        for (int j = 0; j < n; ++j) {
            int colFlips = 0;
            for (int i = 0, k = m - 1; i < k; ++i, --k) {
                if (grid[i][j] != grid[k][j]) {
                    colFlips++;
                }
            }
            totalColFlips += colFlips;
        }

        return min(totalRowFlips, totalColFlips);
    }
};









class Solution {
public:
    int minFlips(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();

        int res = 0;
        int ans = 0;

        for (int i = 0; i < m; ++i) {
            int ress = 0;
            for (int j = 0, k = n - 1; j < k; ++j, --k) {
                if (grid[i][j] != grid[i][k]) {
                    ress++;
                }
            }
            res += ress;
        }

        for (int j = 0; j < n; ++j) {
            int anss = 0;
            for (int i = 0, k = m - 1; i < k; ++i, --k) {
                if (grid[i][j] != grid[k][j]) {
                    anss++;
                }
            }
            ans += anss;
        }

        return min(res, ans);
    }
};






class Solution {
public:
    int minFlips(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        int ans = 0;

        for (int i = 0; i < (n + 1) / 2; ++i) {
            for (int j = 0; j < (m + 1) / 2; ++j) {
                vector<int> cnt(2, 0);
                
                cnt[a[i][j]]++;
                if (i != n - 1 - i) cnt[a[n - 1 - i][j]]++;
                if (j != m - 1 - j) cnt[a[i][m - 1 - j]]++;
                if (i != n - 1 - i && j != m - 1 - j) cnt[a[n - 1 - i][m - 1 - j]]++;
                
                ans += min(cnt[0], cnt[1]);
            }
        }
        
        return ans;
    }
